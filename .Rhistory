# number of group ID for lines for the 1st var
num_sin1 = round(num_lines*prop_sin)
num_cos1 = round(num_lines*prop_cos)
num_noise = num_lines - (num_sin1 + num_cos1)
# assign a group id for each line for what signal is used for the first variable
# 1 = sin wave
# 2 = cos wave
# 3 = random noise
var1ID = rep(c(1,2,3), times = c(num_sin1, num_cos1, num_noise) )
var1ID
rm(prop_sin, prop_cos, prop_noise, num_sin1, num_cos1, num_noise)
## assign a group id for each line for what signal is used for the second variable ##
# 1 = same signal as var 1
# 2 = random other group
# proportion same signal
prop_same = .4
# proportion not same signal
prop_diff = 1-(prop_same)
# number of a given group ID for lines for the 2nd var
num_same = round(num_lines*prop_same)
num_diff = num_lines - num_same
var2ID = sample( rep(c(1,2), times = c(num_same, num_diff) ) )
print( table(var2ID)/num_lines )
var2ID
rm(prop_same, prop_diff, num_same, num_diff)
## create dataframe of observations ##
# initialize empty list of dataframes
sim_list = list()
# loop over lines to assing variables depending on the var1 and var2 ids
for (i in 1:num_lines) {
y1 = generateSignal(var1ID[i], x, noise)
# var 2 specifications
if( var2ID[i] == 1 ) {
# generate the same signal as y1 if var2ID[i] == 1
var2_signal = var1ID[i]
y2 = generateSignal(var1ID[i], x, noise)
} else {
# generate different signal as y1 if var2ID[i] == 2
# randomly choose other signal to use
var2_signal = sample(setdiff(c(1,2,3), var1ID[i]), 1)
y2 = generateSignal(var2_signal, x, noise)
}
sim_list[[i]] = tibble(date = x,
var1 = y1,
var2 = y2,
line_order = i,
isDifferent = var2ID[i],
var1_signal = var1ID[i],
var2_signal = var2_signal)
}
# bind together rows
simulation_df = bind_rows(sim_list)
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var2, color = factor(var2_signal) ), alpha = .5 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var1, color = factor(var2_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var2, color = factor(var1_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var1, color = factor(var1_signal) ), alpha = .5 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var2, color = factor(var2_signal) ), alpha = .5 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var1, color = factor(var2_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var2, color = factor(var1_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = var1, y = var2, color = factor(var1_signal) ), alpha = .2 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = var1, y = var2, color = factor(var1_signal) ), alpha = .2 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = var1, y = var2, color = factor(var2_signal) ), alpha = .2 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = var1, y = var2, color = factor(isDifferentl) ), alpha = .2 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = var1, y = var2, color = factor(isDifferent) ), alpha = .2 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var1, color = factor(var1_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var2, color = factor(var2_signal) ), alpha = .3 )
knitr::opts_chunk$set(echo = TRUE)
source("omni_functions.R")
source("/Users/josephsalzer/research/exostat/readSpectra.R")
# generate signal from a group ID, vector of observations, and  sigma noise specification
# Group ID
# 1 = sin wave
# 2 = cos wave
# 3 = linear
# 4 = random noise
generateSignal = function(groupID, obs, sigma) {
num_obs = length(obs)
if (groupID == 1) {
y = 2*sin(obs) + rnorm(num_obs, sd = sigma)
} else if (groupID == 2) {
y = -2*cos(obs) + rnorm(num_obs, sd = sigma)
} else if (groupID == 3) {
y = -.5*obs + 3 + rnorm(num_obs, sd = sigma)
} else {
y = rnorm(num_obs, sd = sigma)
}
return(y)
}
# calculate p-value from permutation test
permPvalue = function(vec, value) {
upperSum = sum( vec > value )
n = length(vec)
return( (1+upperSum)/(n+1) )
}
# number of times, days
num_times = 100
# number of lines, vertices, nodes, etc
num_lines = 100
# x values ("time") for all variables
x = seq(0,10,length.out=num_times)
# embedding dim
n_dim = 2
# the variables under consideration
vars = c("var1", "var2")
# noise (sd) for the first variable
noise = .4
# proportion sin wave
prop_sin = .5
# proportion cos wave
prop_cos = .3
# proportion
prop_noise = 1-(prop_sin + prop_cos)
# indices of lines
lineIdx = seq(1, num_lines)
# number of permutations
P = 2000
# number of group ID for lines for the 1st var
num_sin1 = round(num_lines*prop_sin)
num_cos1 = round(num_lines*prop_cos)
num_noise = num_lines - (num_sin1 + num_cos1)
# assign a group id for each line for what signal is used for the first variable
# 1 = sin wave
# 2 = cos wave
# 3 = random noise
var1ID = rep(c(1,2,3), times = c(num_sin1, num_cos1, num_noise) )
var1ID
rm(prop_sin, prop_cos, prop_noise, num_sin1, num_cos1, num_noise)
## assign a group id for each line for what signal is used for the second variable ##
# 1 = same signal as var 1
# 2 = random other group
# proportion same signal
prop_same = .4
# proportion not same signal
prop_diff = 1-(prop_same)
# number of a given group ID for lines for the 2nd var
num_same = round(num_lines*prop_same)
num_diff = num_lines - num_same
var2ID = sample( rep(c(1,2), times = c(num_same, num_diff) ) )
print( table(var2ID)/num_lines )
var2ID
rm(prop_same, prop_diff, num_same, num_diff)
## create dataframe of observations ##
# initialize empty list of dataframes
sim_list = list()
# loop over lines to assing variables depending on the var1 and var2 ids
for (i in 1:num_lines) {
y1 = generateSignal(var1ID[i], x, noise)
# var 2 specifications
if( var2ID[i] == 1 ) {
# generate the same signal as y1 if var2ID[i] == 1
var2_signal = var1ID[i]
y2 = generateSignal(var1ID[i], x, noise)
} else {
# generate different signal as y1 if var2ID[i] == 2
# randomly choose other signal to use
var2_signal = sample(setdiff(c(1,2,3), var1ID[i]), 1)
y2 = generateSignal(var2_signal, x, noise)
}
sim_list[[i]] = tibble(date = x,
var1 = y1,
var2 = y2,
line_order = i,
isDifferent = var2ID[i],
var1_signal = var1ID[i],
var2_signal = var2_signal)
}
# bind together rows
simulation_df = bind_rows(sim_list)
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var1, color = factor(var1_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var2, color = factor(var2_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var1, color = factor(var2_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var2, color = factor(var1_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = var1, y = var2, color = factor(var1_signal) ), alpha = .2 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = var1, y = var2, color = factor(var2_signal) ), alpha = .2 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = var1, y = var2, color = factor(isDifferent) ), alpha = .2 )
simulation_df
# embedding dim
n_dim = 2
# the variables under consideration
vars = c("var1", "var2")
# similarity matrix of each line-variable pair
sim_mat = build_sim_matrix(simulation_df, vars)
# create true similarity array
trueArray = mat_to_array(sim_mat, length(vars))
# omni-embed mutli-array and assign ids
embedding = data.frame( omni_embed(trueArray, n_dim)$embedding )
embedding$line_order = factor( rep(rownames(trueArray[,,1]), 2) )
embedding$network_id = rep(vars, each=dim(embedding)[1]/2)
simulation_df
simulation_df %>% mutate(line_order = factor(line_order)) %>% select(line_order,isDifferent,var1_signal,var2_signal) %>% unique() %>%
inner_join(embedding, by = "line_order")  %>%
ggplot() +
geom_point(mapping = aes(x = X1, y = X2, color =  factor(network_id) ), alpha = .7 )
simulation_df %>% mutate(line_order = factor(line_order)) %>% select(line_order,isDifferent,var1_signal,var2_signal) %>% unique() %>%
inner_join(embedding, by = "line_order") %>%
ggplot() +
geom_point(mapping = aes(x = X1, y = X2, shape = factor(var1_signal), color =  factor(var2_signal) ), alpha = .7 )
simulation_df %>% mutate(line_order = factor(line_order)) %>% select(line_order,isDifferent,var1_signal,var2_signal) %>% unique() %>%
inner_join(embedding, by = "line_order") %>%
ggplot() +
geom_point(mapping = aes(x = X1, y = X2, color =  factor(isDifferent) ), alpha = .7 )
simulation_df %>% mutate(line_order = factor(line_order)) %>% select(line_order,isDifferent,var1_signal,var2_signal) %>% unique() %>%
inner_join(embedding, by = "line_order")  %>%
ggplot() +
geom_point(mapping = aes(x = X1, y = X2, color =  factor(network_id), shape =  factor(isDifferent) ), alpha = .7 )
knitr::opts_chunk$set(echo = TRUE)
source("omni_functions.R")
source("/Users/josephsalzer/research/exostat/readSpectra.R")
# generate signal from a group ID, vector of observations, and  sigma noise specification
# Group ID
# 1 = sin wave
# 2 = cos wave
# 3 = linear
# 4 = random noise
generateSignal = function(groupID, obs, sigma) {
num_obs = length(obs)
if (groupID == 1) {
y = 2*sin(obs) + rnorm(num_obs, sd = sigma)
} else if (groupID == 2) {
y = -2*cos(obs) + rnorm(num_obs, sd = sigma)
} else if (groupID == 3) {
y = -.5*obs + 3 + rnorm(num_obs, sd = sigma)
} else {
y = rnorm(num_obs, sd = sigma)
}
return(y)
}
# calculate p-value from permutation test
permPvalue = function(vec, value) {
upperSum = sum( vec > value )
n = length(vec)
return( (1+upperSum)/(n+1) )
}
# number of times, days
num_times = 100
# number of lines, vertices, nodes, etc
num_lines = 100
# x values ("time") for all variables
x = seq(0,10,length.out=num_times)
# embedding dim
n_dim = 2
# the variables under consideration
vars = c("var1", "var2")
# noise (sd) for the first variable
noise = .4
# proportion sin wave
prop_sin = .5
# proportion cos wave
prop_cos = .3
# proportion
prop_noise = 1-(prop_sin + prop_cos)
# indices of lines
lineIdx = seq(1, num_lines)
# number of permutations
P = 2000
# number of group ID for lines for the 1st var
num_sin1 = round(num_lines*prop_sin)
num_cos1 = round(num_lines*prop_cos)
num_noise = num_lines - (num_sin1 + num_cos1)
# assign a group id for each line for what signal is used for the first variable
# 1 = sin wave
# 2 = cos wave
# 3 = random noise
var1ID = rep(c(1,2,3), times = c(num_sin1, num_cos1, num_noise) )
var1ID
rm(prop_sin, prop_cos, prop_noise, num_sin1, num_cos1, num_noise)
## assign a group id for each line for what signal is used for the second variable ##
# 1 = same signal as var 1
# 2 = random other group
# proportion same signal
prop_same = .4
# proportion not same signal
prop_diff = 1-(prop_same)
# number of a given group ID for lines for the 2nd var
num_same = round(num_lines*prop_same)
num_diff = num_lines - num_same
var2ID = sample( rep(c(1,2), times = c(num_same, num_diff) ) )
print( table(var2ID)/num_lines )
var2ID
rm(prop_same, prop_diff, num_same, num_diff)
## create dataframe of observations ##
# initialize empty list of dataframes
sim_list = list()
# loop over lines to assing variables depending on the var1 and var2 ids
for (i in 1:num_lines) {
y1 = generateSignal(var1ID[i], x, noise)
# var 2 specifications
if( var2ID[i] == 1 ) {
# generate the same signal as y1 if var2ID[i] == 1
var2_signal = var1ID[i]
y2 = generateSignal(var1ID[i], x, noise)
} else {
# generate different signal as y1 if var2ID[i] == 2
# randomly choose other signal to use
var2_signal = sample(setdiff(c(1,2,3), var1ID[i]), 1)
y2 = generateSignal(var2_signal, x, noise)
}
sim_list[[i]] = tibble(date = x,
var1 = y1,
var2 = y2,
line_order = i,
isDifferent = var2ID[i],
var1_signal = var1ID[i],
var2_signal = var2_signal)
}
# bind together rows
simulation_df = bind_rows(sim_list)
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var1, color = factor(var1_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var2, color = factor(var2_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var1, color = factor(var2_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = date, y = var2, color = factor(var1_signal) ), alpha = .3 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = var1, y = var2, color = factor(var1_signal) ), alpha = .2 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = var1, y = var2, color = factor(var2_signal) ), alpha = .2 )
simulation_df %>%
ggplot() +
geom_point(mapping = aes(x = var1, y = var2, color = factor(isDifferent) ), alpha = .2 )
simulation_df
# embedding dim
n_dim = 2
# the variables under consideration
vars = c("var1", "var2")
# similarity matrix of each line-variable pair
sim_mat = build_sim_matrix(simulation_df, vars)
# create true similarity array
trueArray = mat_to_array(sim_mat, length(vars))
# omni-embed mutli-array and assign ids
embedding = data.frame( omni_embed(trueArray, n_dim)$embedding )
embedding$line_order = factor( rep(rownames(trueArray[,,1]), 2) )
embedding$network_id = rep(vars, each=dim(embedding)[1]/2)
simulation_df
simulation_df %>% mutate(line_order = factor(line_order)) %>% select(line_order,isDifferent,var1_signal,var2_signal) %>% unique() %>%
inner_join(embedding, by = "line_order")  %>%
ggplot() +
geom_point(mapping = aes(x = X1, y = X2, color =  factor(network_id), shape =  factor(isDifferent) ), alpha = .7 )
simulation_df %>% mutate(line_order = factor(line_order)) %>% select(line_order,isDifferent,var1_signal,var2_signal) %>% unique() %>%
inner_join(embedding, by = "line_order") %>%
ggplot() +
geom_point(mapping = aes(x = X1, y = X2, shape = factor(var1_signal), color =  factor(var2_signal) ), alpha = .7 )
# get pairwise distances between embeddings
distMat = dist_matrix(embedding, n_dim)
# get true distances between points
trueDistances = diag( distMat[c(1:num_lines), num_lines+c(1:num_lines)] )
names(trueDistances) = unique( str_split_fixed(rownames(sim_mat), ":", n = 2)[,2] )
tibble(trueDistances, var2ID, var1ID)
# indices of lines
lineIdx = seq(1, num_lines)
# number of permutations
P = 2000
# create empty dataframe for permuted distances between individual lines, each column is a line and each row is a permutation
perm_df = data.frame(matrix(nrow = P, ncol = num_lines))
# assign column names
colnames(perm_df) = unique( str_split_fixed(rownames(sim_mat), ":", n = 2)[,2] )
# set a seed for replication
set.seed(123)
# start time
start.time = Sys.time()
for (p in 1:P) {
# indices to permute
permIdx = lineIdx[ rbinom(n = length(lineIdx), size = 1, prob = .5) == 1 ]
# create permuted similarity array
permArray = mat_to_array(permute_sim_matrix(sim_mat, permIdx), length(vars))
# omni-embed mutli-array and assign ids
embedding = data.frame( omni_embed(permArray, n_dim)$embedding )
embedding$line_order = factor( rep(rownames(permArray[,,1]), 2) )
embedding$network_id = rep(vars, each=dim(embedding)[1]/2)
# get pairwise distances between embeddings
distMat = dist_matrix(embedding, n_dim)
# place pairwise distance between the same line in the row of the dataframe
perm_df[p,] = diag( distMat[c(1:num_lines),num_lines+c(1:num_lines)] )
if(p%%100==0) {
print(p)
}
}
# end time
end.time = Sys.time()
# print
print(end.time - start.time)
i = 3
ggplot() +
geom_histogram(mapping = aes(x = perm_df[,i])) +
geom_vline(xintercept = trueDistances[i], color = "red") +
ggtitle(colnames(perm_df)[i])
i = 10
ggplot() +
geom_histogram(mapping = aes(x = perm_df[,i])) +
geom_vline(xintercept = trueDistances[i], color = "red") +
ggtitle(colnames(perm_df)[i])
var1ID[i]
var2ID[i]
# calculate p-value from permutation test
permPvalue = function(vec, value) {
upperSum = sum( vec > value )
lowerSum = sum( vec < value )
n = length(vec)
return( min((1+upperSum)/(n+1),
(1+lowerSum)/(n+1) ) )
}
# get pvalues associated with whatever test
pvals = sapply(1:ncol(perm_df), function(i) permPvalue(perm_df[[i]],
trueDistances[i]) )
# adjust p-values
#pvals = p.adjust(pvals, method = "holm")
pvals
# logical vector for whether a p value is < .05 or not
less05 = pvals < .05
# logical vector for if we should reject the NH (i.e the signal is different in var1 than var2)
isDifferent = (var2ID == 2)
less05
isDifferent
# confusion matrix
cm = table(less05,isDifferent)
cm
# true positive rate
tpr = cm[2,2]/(cm[2,2] + cm[1,2])
tpr
# false positive rate
fpr = cm[2,1]/(cm[2,1] + cm[1,1])
fpr
cm = table(factor(less05, levels = c(T,F)),factor(isDifferent, levels = c(T,F)))
cm
# true positive rate
tpr = cm[1,1]/(cm[1,1] + cm[2,1])
tpr
# false positive rate
fpr = cm[1,2]/(cm[1,2] + cm[2,2])
fpr
tibble(trueDistances, var2ID, var1ID)
# proportions of var 2 to loop thru
props_var2 = seq(0,1, by = .1)
props_var2
sim1_prop_v_errors_df = readRDS("sim1_prop_v_errors_noAdjust.rds")
sim1_prop_v_errors_df %>%
ggplot() +
geom_point(mapping = aes(x = prop, y = tpr), color = "orange")+
geom_point(mapping = aes(x = prop, y = fpr), color = "purple") +
xlab("proportion of lines that are the same signal") +
ylab("fpr (purple) and tpr (orange)")
sim1_prop_v_errors_df = readRDS("sim1_prop_v_errors.rds")
sim1_prop_v_errors_df %>%
ggplot() +
geom_point(mapping = aes(x = prop, y = tpr), color = "orange")+
geom_point(mapping = aes(x = prop, y = fpr), color = "purple") +
xlab("proportion of lines that are the same signal") +
ylab("fpr (purple) and tpr (orange)")
sim2_prop_v_errors_df = readRDS("sim2_prop_v_errors.rds")
sim2_prop_v_errors_df %>%
ggplot() +
geom_point(mapping = aes(x = prop, y = tpr), color = "orange")+
geom_point(mapping = aes(x = prop, y = fpr), color = "purple") +
xlab("proportion of lines that are the same signal") +
ylab("fpr (purple) and tpr (orange)")
sim3_prop_v_errors_df = readRDS("sim3_prop_v_errors.rds")
sim3_prop_v_errors_df %>%
ggplot() +
geom_point(mapping = aes(x = prop, y = tpr), color = "orange")+
geom_point(mapping = aes(x = prop, y = fpr), color = "purple") +
xlab("proportion of lines that are the same signal") +
ylab("fpr (purple) and tpr (orange)")
