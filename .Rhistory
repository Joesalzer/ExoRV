filter(ccf_val == min(ccf_val)))
efficient_cross_correlation(smooth_fit1, smooth_fit2, wavelength_grid)
rv_injected = 10
smooth_fit2_planet = smooth.spline(x = smooth_fit2$x/(1+rv_injected/299792458),
y = smooth_fit2$y,
w = smooth_fit2$w)
ggplot() +
geom_line(mapping = aes(x = wavelength_grid, y = predict(smooth_fit1,wavelength_grid)$y)) +
geom_line(mapping = aes(x = wavelength_grid, y = predict(smooth_fit2_planet,wavelength_grid)$y), color = "red") +
xlab("wavelength") +
ylab("flux")
efficient_cross_correlation(smooth_fit1, smooth_fit2_planet, wavelength_grid)
knitr::opts_chunk$set(echo = TRUE)
library(pbmcapply)
#library(plotly)
source("/Users/josephsalzer/research/exostat/readSpectra.R")
#source("embed_functions.R")
# working directory
WD_DATA = "/Users/josephsalzer/research/exostat/"
LINE_NAME = "5111.06935_54"
# number of samples to take for the CCF shifting
NUM_SAMPLES_CCF = 10000
template = readRDS(str_c("lines/",LINE_NAME,"/template.rds"))
wavelength_template_lower = template$wavelength_template_lower
wavelength_template_upper = template$wavelength_template_upper
rm(template)
# get a fine wavelength grid between the beginning and end of the template
wavelength_grid = seq(wavelength_template_lower + (wavelength_template_upper - wavelength_template_lower)/6,
wavelength_template_upper - (wavelength_template_upper - wavelength_template_lower)/6,
length.out = NUM_SAMPLES_CCF )
smoothfit_dir = str_c("lines/",LINE_NAME,"/days/")
all_times = str_sub(str_split_fixed(list.files(smoothfit_dir), "_", n = 3)[,3], end = -5)
###########################
## get cross correlation between two curves ##
###########################
# FIT1, FIT2 : smooth splines for two days
# x_grid : grid of wavelength values
# max_rv : max rv between the two curves
# rv_shift : rv shifts between fluxes
cross_correlation = function(FIT1, FIT2, x_grid, max_rv, rv_shift = .01, c_light = 299792458) {
# initialize rv lags and ccf distance values
rv_lags = seq(-max_rv, max_rv, by = rv_shift)
ccf_value = numeric(length(rv_lags))
# get the flux values for the first day
y1 = predict(FIT1, x_grid)$y
for (i in seq_along(rv_lags)) {
rv_lag = rv_lags[i]
# get the shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light + rv_lag) * x_grid)$y
# get the ccf distance
ccf_value[i] = sqrt(sum((y1-y2) ^ 2))
}
return(data.frame(rv_lag = rv_lags, ccf_val = ccf_value))
}
###########################
## efficient ccf assuming the distance is convex, Eucledian dist ##
###########################
# FIT1, FIT2 : smooth splines for two days
# x_grid : grid of wavelength values
# rv_shift : rv shifts between fluxes
# note that this function assumes that the ccf function is concave!!
efficient_cross_correlation = function(FIT1, FIT2, x_grid, rv_shift = .01, c_light = 299792458) {
# get the flux values for the first day
y1 = predict(FIT1, x_grid)$y
# initial rv shift
rv_lag = rv_shift
# get the left shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light - rv_lag) * x_grid)$y
left_ccf = sqrt(sum((y1-y2) ^ 2))
# get the right shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light + rv_lag) * x_grid)$y
right_ccf = sqrt(sum((y1-y2) ^ 2))
if (left_ccf < right_ccf) {
while(left_ccf < right_ccf) {
rv_lag = rv_lag + rv_shift
right_ccf = left_ccf
# get the left shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light - rv_lag) * x_grid)$y
left_ccf = sqrt(sum((y1-y2) ^ 2))
}
return( list(rv_lag = -rv_lag+rv_shift,
distance = right_ccf) )
} else {
while(left_ccf > right_ccf) {
rv_lag = rv_lag + rv_shift
left_ccf = right_ccf
# get the right shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light + rv_lag) * x_grid)$y
right_ccf = sqrt(sum((y1-y2) ^ 2))
}
return( list(rv_lag = rv_lag-rv_shift,
distance = left_ccf) )
}
}
###########################
## function that creates a list of all pairwise integers from 1 to n ##
###########################
# n - integer to create pairs from
create_pairs = function(n) {
pairs_list = list()
index = 1
for (i in 1:(n - 1)) {
for (j in (i + 1):n) {
pairs_list[[index]] = c(i, j)
index = index + 1
}
}
return(pairs_list)
}
###########################
## function to save the ccf distance between two days ##
###########################
# indices : a size 2 vector of which indices of timeIDs to get the ccf distance of
# timeIDs : vector of all of the date names
ccfDist_parallel = function(indices, timeIDs) {
name1 = timeIDs[indices[1]]
name2 = timeIDs[indices[2]]
# create directory called "distances" in working directory
if (!dir.exists( str_c("lines/",LINE_NAME,"/ccf_distances/") )) {dir.create(str_c("lines/",LINE_NAME,"/ccf_distances/"))}
smooth_fit1 = readRDS( str_c(smoothfit_dir,"smooth_fit_",name1,".rds") )
smooth_fit2 = readRDS( str_c(smoothfit_dir,"smooth_fit_",name2,".rds") )
saveRDS(
efficient_cross_correlation(smooth_fit1, smooth_fit2, wavelength_grid),
str_c("lines/",LINE_NAME,"/ccf_distances/",name1,"#",name2,".rds")
)
}
# pairwise indices over all days
index_list = create_pairs(length(all_times))
ccf_list <- pbmclapply(index_list, FUN = ccfDist_parallel, timeIDs = all_times, mc.cores = 8)
# list of all pairwise ccf files
ccfFileList = list.files(str_c("lines/",LINE_NAME,"/ccf_distances"))
# initialize matrices with 0's
distance_matrix = matrix(0, nrow = length(all_times), ncol = length(all_times))
rownames(distance_matrix) = all_times
colnames(distance_matrix) = all_times
rv_matrix = matrix(0, nrow = length(all_times), ncol = length(all_times))
rownames(rv_matrix) = all_times
colnames(rv_matrix) = all_times
# populate the matrix
for (fileID in ccfFileList) {
# load the RDS file
obj = readRDS( str_c("lines/",LINE_NAME,"/ccf_distances/",fileID) )
# extract days from the file name
time_pair = which(all_times %in% str_split_1(str_sub(fileID,end = -5),"#"))
# get the distance and shifts
distance = obj$distance
shift = obj$rv_lag
# fill in the distance matrix (symmetrically)
distance_matrix[time_pair[1], time_pair[2]] = distance
distance_matrix[time_pair[2], time_pair[1]] = distance
# fill in the rv matrix (symmetrically)
rv_matrix[time_pair[1], time_pair[2]] = -shift
rv_matrix[time_pair[2], time_pair[1]] = shift
rm(obj, time_pair, distance, shift)
}
saveRDS(distance_matrix, str_c("lines/",LINE_NAME,"/distanceCCF_mat.rds"))
saveRDS(rv_matrix, str_c("lines/",LINE_NAME,"/rvCCF_mat.rds"))
knitr::opts_chunk$set(echo = TRUE)
library(pbmcapply)
#library(plotly)
source("/Users/josephsalzer/research/exostat/readSpectra.R")
#source("embed_functions.R")
# working directory
WD_DATA = "/Users/josephsalzer/research/exostat/"
LINE_NAME = "4318.92378_31"
# number of samples to take for the CCF shifting
NUM_SAMPLES_CCF = 10000
template = readRDS(str_c("lines/",LINE_NAME,"/template.rds"))
wavelength_template_lower = template$wavelength_template_lower
wavelength_template_upper = template$wavelength_template_upper
rm(template)
# get a fine wavelength grid between the beginning and end of the template
wavelength_grid = seq(wavelength_template_lower + (wavelength_template_upper - wavelength_template_lower)/6,
wavelength_template_upper - (wavelength_template_upper - wavelength_template_lower)/6,
length.out = NUM_SAMPLES_CCF )
smoothfit_dir = str_c("lines/",LINE_NAME,"/days/")
all_times = str_sub(str_split_fixed(list.files(smoothfit_dir), "_", n = 3)[,3], end = -5)
###########################
## get cross correlation between two curves ##
###########################
# FIT1, FIT2 : smooth splines for two days
# x_grid : grid of wavelength values
# max_rv : max rv between the two curves
# rv_shift : rv shifts between fluxes
cross_correlation = function(FIT1, FIT2, x_grid, max_rv, rv_shift = .01, c_light = 299792458) {
# initialize rv lags and ccf distance values
rv_lags = seq(-max_rv, max_rv, by = rv_shift)
ccf_value = numeric(length(rv_lags))
# get the flux values for the first day
y1 = predict(FIT1, x_grid)$y
for (i in seq_along(rv_lags)) {
rv_lag = rv_lags[i]
# get the shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light + rv_lag) * x_grid)$y
# get the ccf distance
ccf_value[i] = sqrt(sum((y1-y2) ^ 2))
}
return(data.frame(rv_lag = rv_lags, ccf_val = ccf_value))
}
###########################
## efficient ccf assuming the distance is convex, Eucledian dist ##
###########################
# FIT1, FIT2 : smooth splines for two days
# x_grid : grid of wavelength values
# rv_shift : rv shifts between fluxes
# note that this function assumes that the ccf function is concave!!
efficient_cross_correlation = function(FIT1, FIT2, x_grid, rv_shift = .01, c_light = 299792458) {
# get the flux values for the first day
y1 = predict(FIT1, x_grid)$y
# initial rv shift
rv_lag = rv_shift
# get the left shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light - rv_lag) * x_grid)$y
left_ccf = sqrt(sum((y1-y2) ^ 2))
# get the right shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light + rv_lag) * x_grid)$y
right_ccf = sqrt(sum((y1-y2) ^ 2))
if (left_ccf < right_ccf) {
while(left_ccf < right_ccf) {
rv_lag = rv_lag + rv_shift
right_ccf = left_ccf
# get the left shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light - rv_lag) * x_grid)$y
left_ccf = sqrt(sum((y1-y2) ^ 2))
}
return( list(rv_lag = -rv_lag+rv_shift,
distance = right_ccf) )
} else {
while(left_ccf > right_ccf) {
rv_lag = rv_lag + rv_shift
left_ccf = right_ccf
# get the right shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light + rv_lag) * x_grid)$y
right_ccf = sqrt(sum((y1-y2) ^ 2))
}
return( list(rv_lag = rv_lag-rv_shift,
distance = left_ccf) )
}
}
dayID1 = 1
dayID2 = 2
smooth_fit1 = readRDS( str_c(smoothfit_dir,"smooth_fit_",all_times[dayID1],".rds") )
smooth_fit2 = readRDS( str_c(smoothfit_dir,"smooth_fit_",all_times[dayID2],".rds") )
ggplot() +
geom_point(mapping = aes(x = smooth_fit1$x, y = smooth_fit1$y), alpha = .8, size = .5) +
geom_point(mapping = aes(x = smooth_fit2$x, y = smooth_fit2$y), color = "red", alpha = .8, size = .5) +
geom_vline(xintercept = max(wavelength_grid)) +
geom_vline(xintercept = min(wavelength_grid)) +
xlab("wavelength") +
ylab("flux")
ggplot() +
geom_line(mapping = aes(x = wavelength_grid, y = predict(smooth_fit1,wavelength_grid)$y)) +
geom_line(mapping = aes(x = wavelength_grid, y = predict(smooth_fit2,wavelength_grid)$y), color = "red") +
xlab("wavelength") +
ylab("flux")
ccf_df = cross_correlation(smooth_fit1, smooth_fit2, wavelength_grid, max_rv = 6)
ccf_df %>%
ggplot() +
geom_line(mapping = aes(x = rv_lag, y = ccf_val))
print(ccf_df %>%
filter(ccf_val == min(ccf_val)))
efficient_cross_correlation(smooth_fit1, smooth_fit2, wavelength_grid)
knitr::opts_chunk$set(echo = TRUE)
library(pbmcapply)
#library(plotly)
source("/Users/josephsalzer/research/exostat/readSpectra.R")
#source("embed_functions.R")
# working directory
WD_DATA = "/Users/josephsalzer/research/exostat/"
LINE_NAME = "5114.85921_54"
# number of samples to take for the CCF shifting
NUM_SAMPLES_CCF = 10000
template = readRDS(str_c("lines/",LINE_NAME,"/template.rds"))
wavelength_template_lower = template$wavelength_template_lower
wavelength_template_upper = template$wavelength_template_upper
rm(template)
# get a fine wavelength grid between the beginning and end of the template
wavelength_grid = seq(wavelength_template_lower + (wavelength_template_upper - wavelength_template_lower)/6,
wavelength_template_upper - (wavelength_template_upper - wavelength_template_lower)/6,
length.out = NUM_SAMPLES_CCF )
smoothfit_dir = str_c("lines/",LINE_NAME,"/days/")
all_times = str_sub(str_split_fixed(list.files(smoothfit_dir), "_", n = 3)[,3], end = -5)
###########################
## get cross correlation between two curves ##
###########################
# FIT1, FIT2 : smooth splines for two days
# x_grid : grid of wavelength values
# max_rv : max rv between the two curves
# rv_shift : rv shifts between fluxes
cross_correlation = function(FIT1, FIT2, x_grid, max_rv, rv_shift = .01, c_light = 299792458) {
# initialize rv lags and ccf distance values
rv_lags = seq(-max_rv, max_rv, by = rv_shift)
ccf_value = numeric(length(rv_lags))
# get the flux values for the first day
y1 = predict(FIT1, x_grid)$y
for (i in seq_along(rv_lags)) {
rv_lag = rv_lags[i]
# get the shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light + rv_lag) * x_grid)$y
# get the ccf distance
ccf_value[i] = sqrt(sum((y1-y2) ^ 2))
}
return(data.frame(rv_lag = rv_lags, ccf_val = ccf_value))
}
###########################
## efficient ccf assuming the distance is convex, Eucledian dist ##
###########################
# FIT1, FIT2 : smooth splines for two days
# x_grid : grid of wavelength values
# rv_shift : rv shifts between fluxes
# note that this function assumes that the ccf function is concave!!
efficient_cross_correlation = function(FIT1, FIT2, x_grid, rv_shift = .01, c_light = 299792458) {
# get the flux values for the first day
y1 = predict(FIT1, x_grid)$y
# initial rv shift
rv_lag = rv_shift
# get the left shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light - rv_lag) * x_grid)$y
left_ccf = sqrt(sum((y1-y2) ^ 2))
# get the right shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light + rv_lag) * x_grid)$y
right_ccf = sqrt(sum((y1-y2) ^ 2))
if (left_ccf < right_ccf) {
while(left_ccf < right_ccf) {
rv_lag = rv_lag + rv_shift
right_ccf = left_ccf
# get the left shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light - rv_lag) * x_grid)$y
left_ccf = sqrt(sum((y1-y2) ^ 2))
}
return( list(rv_lag = -rv_lag+rv_shift,
distance = right_ccf) )
} else {
while(left_ccf > right_ccf) {
rv_lag = rv_lag + rv_shift
left_ccf = right_ccf
# get the right shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light + rv_lag) * x_grid)$y
right_ccf = sqrt(sum((y1-y2) ^ 2))
}
return( list(rv_lag = rv_lag-rv_shift,
distance = left_ccf) )
}
}
dayID1 = 1
dayID2 = 2
smooth_fit1 = readRDS( str_c(smoothfit_dir,"smooth_fit_",all_times[dayID1],".rds") )
smooth_fit2 = readRDS( str_c(smoothfit_dir,"smooth_fit_",all_times[dayID2],".rds") )
ggplot() +
geom_point(mapping = aes(x = smooth_fit1$x, y = smooth_fit1$y), alpha = .8, size = .5) +
geom_point(mapping = aes(x = smooth_fit2$x, y = smooth_fit2$y), color = "red", alpha = .8, size = .5) +
geom_vline(xintercept = max(wavelength_grid)) +
geom_vline(xintercept = min(wavelength_grid)) +
xlab("wavelength") +
ylab("flux")
ggplot() +
geom_line(mapping = aes(x = wavelength_grid, y = predict(smooth_fit1,wavelength_grid)$y)) +
geom_line(mapping = aes(x = wavelength_grid, y = predict(smooth_fit2,wavelength_grid)$y), color = "red") +
xlab("wavelength") +
ylab("flux")
ccf_df = cross_correlation(smooth_fit1, smooth_fit2, wavelength_grid, max_rv = 6)
ccf_df %>%
ggplot() +
geom_line(mapping = aes(x = rv_lag, y = ccf_val))
print(ccf_df %>%
filter(ccf_val == min(ccf_val)))
efficient_cross_correlation(smooth_fit1, smooth_fit2, wavelength_grid)
knitr::opts_chunk$set(echo = TRUE)
library(pbmcapply)
#library(plotly)
source("/Users/josephsalzer/research/exostat/readSpectra.R")
#source("embed_functions.R")
# working directory
WD_DATA = "/Users/josephsalzer/research/exostat/"
LINE_NAME = "5114.85921_54"
# number of samples to take for the CCF shifting
NUM_SAMPLES_CCF = 10000
template = readRDS(str_c("lines/",LINE_NAME,"/template.rds"))
wavelength_template_lower = template$wavelength_template_lower
wavelength_template_upper = template$wavelength_template_upper
rm(template)
# get a fine wavelength grid between the beginning and end of the template
wavelength_grid = seq(wavelength_template_lower + (wavelength_template_upper - wavelength_template_lower)/6,
wavelength_template_upper - (wavelength_template_upper - wavelength_template_lower)/6,
length.out = NUM_SAMPLES_CCF )
smoothfit_dir = str_c("lines/",LINE_NAME,"/days/")
all_times = str_sub(str_split_fixed(list.files(smoothfit_dir), "_", n = 3)[,3], end = -5)
###########################
## get cross correlation between two curves ##
###########################
# FIT1, FIT2 : smooth splines for two days
# x_grid : grid of wavelength values
# max_rv : max rv between the two curves
# rv_shift : rv shifts between fluxes
cross_correlation = function(FIT1, FIT2, x_grid, max_rv, rv_shift = .01, c_light = 299792458) {
# initialize rv lags and ccf distance values
rv_lags = seq(-max_rv, max_rv, by = rv_shift)
ccf_value = numeric(length(rv_lags))
# get the flux values for the first day
y1 = predict(FIT1, x_grid)$y
for (i in seq_along(rv_lags)) {
rv_lag = rv_lags[i]
# get the shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light + rv_lag) * x_grid)$y
# get the ccf distance
ccf_value[i] = sqrt(sum((y1-y2) ^ 2))
}
return(data.frame(rv_lag = rv_lags, ccf_val = ccf_value))
}
###########################
## efficient ccf assuming the distance is convex, Eucledian dist ##
###########################
# FIT1, FIT2 : smooth splines for two days
# x_grid : grid of wavelength values
# rv_shift : rv shifts between fluxes
# note that this function assumes that the ccf function is concave!!
efficient_cross_correlation = function(FIT1, FIT2, x_grid, rv_shift = .01, c_light = 299792458) {
# get the flux values for the first day
y1 = predict(FIT1, x_grid)$y
# initial rv shift
rv_lag = rv_shift
# get the left shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light - rv_lag) * x_grid)$y
left_ccf = sqrt(sum((y1-y2) ^ 2))
# get the right shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light + rv_lag) * x_grid)$y
right_ccf = sqrt(sum((y1-y2) ^ 2))
if (left_ccf < right_ccf) {
while(left_ccf < right_ccf) {
rv_lag = rv_lag + rv_shift
right_ccf = left_ccf
# get the left shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light - rv_lag) * x_grid)$y
left_ccf = sqrt(sum((y1-y2) ^ 2))
}
return( list(rv_lag = -rv_lag+rv_shift,
distance = right_ccf) )
} else {
while(left_ccf > right_ccf) {
rv_lag = rv_lag + rv_shift
left_ccf = right_ccf
# get the right shifted fluxes for the second day
y2 = predict(FIT2, c_light/(c_light + rv_lag) * x_grid)$y
right_ccf = sqrt(sum((y1-y2) ^ 2))
}
return( list(rv_lag = rv_lag-rv_shift,
distance = left_ccf) )
}
}
###########################
## function that creates a list of all pairwise integers from 1 to n ##
###########################
# n - integer to create pairs from
create_pairs = function(n) {
pairs_list = list()
index = 1
for (i in 1:(n - 1)) {
for (j in (i + 1):n) {
pairs_list[[index]] = c(i, j)
index = index + 1
}
}
return(pairs_list)
}
###########################
## function to save the ccf distance between two days ##
###########################
# indices : a size 2 vector of which indices of timeIDs to get the ccf distance of
# timeIDs : vector of all of the date names
ccfDist_parallel = function(indices, timeIDs) {
name1 = timeIDs[indices[1]]
name2 = timeIDs[indices[2]]
# create directory called "distances" in working directory
if (!dir.exists( str_c("lines/",LINE_NAME,"/ccf_distances/") )) {dir.create(str_c("lines/",LINE_NAME,"/ccf_distances/"))}
smooth_fit1 = readRDS( str_c(smoothfit_dir,"smooth_fit_",name1,".rds") )
smooth_fit2 = readRDS( str_c(smoothfit_dir,"smooth_fit_",name2,".rds") )
saveRDS(
efficient_cross_correlation(smooth_fit1, smooth_fit2, wavelength_grid),
str_c("lines/",LINE_NAME,"/ccf_distances/",name1,"#",name2,".rds")
)
}
# pairwise indices over all days
index_list = create_pairs(length(all_times))
ccf_list <- pbmclapply(index_list, FUN = ccfDist_parallel, timeIDs = all_times, mc.cores = 8)
# list of all pairwise ccf files
ccfFileList = list.files(str_c("lines/",LINE_NAME,"/ccf_distances"))
# initialize matrices with 0's
distance_matrix = matrix(0, nrow = length(all_times), ncol = length(all_times))
rownames(distance_matrix) = all_times
colnames(distance_matrix) = all_times
rv_matrix = matrix(0, nrow = length(all_times), ncol = length(all_times))
rownames(rv_matrix) = all_times
colnames(rv_matrix) = all_times
# populate the matrix
for (fileID in ccfFileList) {
# load the RDS file
obj = readRDS( str_c("lines/",LINE_NAME,"/ccf_distances/",fileID) )
# extract days from the file name
time_pair = which(all_times %in% str_split_1(str_sub(fileID,end = -5),"#"))
# get the distance and shifts
distance = obj$distance
shift = obj$rv_lag
# fill in the distance matrix (symmetrically)
distance_matrix[time_pair[1], time_pair[2]] = distance
distance_matrix[time_pair[2], time_pair[1]] = distance
# fill in the rv matrix (symmetrically)
rv_matrix[time_pair[1], time_pair[2]] = -shift
rv_matrix[time_pair[2], time_pair[1]] = shift
rm(obj, time_pair, distance, shift)
}
saveRDS(distance_matrix, str_c("lines/",LINE_NAME,"/distanceCCF_mat.rds"))
saveRDS(rv_matrix, str_c("lines/",LINE_NAME,"/rvCCF_mat.rds"))
