---
title: "Test"
author: "Joe Salzer"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(emmeans)
```

set our mean effects for x and y. below I demonstrate that we can't recover mu_x and mu_y; we only are able to recover the relative difference between each group

what this means for us, our linear model can only recover the change in rv across days

# Emmeans with no continuous vars

```{r}
# set effects for x, y
mu_x = c(-4,8,3)
mu_y = c(-2,7)

# number of observations per x-y pair
n = 10

# standard deviation of error
sd_error = .75

# number of groups in x and y
n_x = length(mu_x)
n_y = length(mu_y)
```

```{r}
set.seed(1234)

# set dataframe, factors 1-n_x for x and 1-n_y for y
# x_effect is the mu for each group in x (same for y_effect)
# eps is error
df = data.frame(
  x = factor( rep(seq(1,n_x), each = n_y*n) ),
  x_effect = rep(mu_x, each = n_y*n),
  y = factor( rep(seq(1,n_y), n_x*n) ),
  y_effect = rep(mu_y, n_x*n),
  eps = rnorm(n_x*n_y*n, sd = sd_error)
)

# set response as additive between x and y (and error)
df = df %>%
  mutate(response = x_effect + y_effect + eps)

df
```


```{r}
#contrasts(df$x) = contr.treatment(length(mu_x))
#contrasts(df$y) = contr.treatment(length(mu_y))
#contrasts(df$x) = contr.treatment(3)
#contrasts(df$x) = contr.helmert(3)
#contrasts(df$x) = contr.SAS(3)
model = lm(response ~ x + y, df )
sum = summary( model )
sum
```






```{r}
df %>% count(x)
df %>% count(y)
```

SE for x and y emmeans
```{r}
sum$sigma
sum$sigma/sqrt(20)
sum$sigma/sqrt(30)
```

```{r}
summary(emmeans(model, specs = "y")) 
```

```{r}
summary(emmeans(model, specs = "x")) 
```

# Emmeans with continuous vars

```{r}
# set effects for x, y, and z
mu_x = c(-4,8,3)
mu_y = c(-2,7)
beta_z = -2

# number of observations per x-y pair
n = 7

# standard deviation of error
sd_error = .75

# number of groups in x and y
n_x = length(mu_x)
n_y = length(mu_y)
```

```{r}
set.seed(12435)
# set dataframe, factors 1-n_x for x and 1-n_y for y
# x_effect is the mu for each group in x (same for y_effect)
# eps is error
df = data.frame(
  x = factor( rep(seq(1,n_x), each = n_y*n) ),
  x_effect = rep(mu_x, each = n_y*n),
  y = factor( rep(seq(1,n_y), n_x*n) ),
  y_effect = rep(mu_y, n_x*n),
  z = runif(n_x*n_y*n),
  eps = rnorm(n_x*n_y*n, sd = sd_error)
)

# set response as additive between x and y (and error)
df = df %>%
  mutate(response = x_effect + y_effect + beta_z*z + eps)

df
```


```{r}
model = lm(response ~ x + y + z, df )
sum = summary( model )
sum
```

```{r}
refGrid = summary(ref_grid(model))
refGrid
```

```{r}
# create a manual refrence grid
manualgrid = with(df, expand.grid(
  x = levels(unique(df$x)),
  y = levels(unique(df$y)),
  z = mean(df$z) ) )
manualgrid
# design matrix
X = model.matrix(~ x+y+z, data = manualgrid)
X
# covariance of coefficients
V = vcov(model)
V
```


```{r}
# manual predictions match with ref_grid summary
X %*% model$coefficients
refGrid$prediction
```

```{r}
# var-covar matrix of predictions:
predVar = X %*% V %*% t(X)
predVar
```

```{r}
# manual predictions match with ref_grid summary
sqrt( diag(predVar) )
refGrid$SE
```


```{r}
# emmeans for either first or second factor
summary(emmeans(model, specs = "x")) 
summary(emmeans(model, specs = "y")) 
```

*The empirical marginal mean is the predicted value, using the average of continuous vars and averaging across the other factor*



For x's:
```{r}
( refGrid$prediction[1] + refGrid$prediction[4] )/2
( refGrid$prediction[2] + refGrid$prediction[5] )/2
( refGrid$prediction[3] + refGrid$prediction[6] )/2

summary(emmeans(model, specs = "x"))$emmean
```

```{r}
sqrt(predVar[1,1] + predVar[4,4] + 2*predVar[1,4])/2
sqrt(predVar[2,2] + predVar[5,5] + 2*predVar[2,5])/2
sqrt(predVar[3,3] + predVar[6,6] + 2*predVar[3,6])/2

summary(emmeans(model, specs = "x"))$SE
```


For y's:
```{r}
( refGrid$prediction[1] + refGrid$prediction[2] + refGrid$prediction[3] )/3
( refGrid$prediction[4] + refGrid$prediction[5] + refGrid$prediction[6] )/3

summary(emmeans(model, specs = "y"))$emmean
```

```{r}
sqrt(predVar[1,1] + predVar[2,2] + predVar[3,3] + 2*predVar[1,2] + 2*predVar[1,3] + 2*predVar[2,3])/3
sqrt(predVar[4,4] + predVar[5,5] + predVar[6,6] + 2*predVar[4,5] + 2*predVar[4,6] + 2*predVar[5,6])/3
summary(emmeans(model, specs = "y"))$SE
```

```{r}

```


